\chapter{Requirements}
\label{chapter:requirements}

The locking manager Warlock was created to replace the existing lock manager
which was a single point of failure in the system. To explore the need for
Warlock and to understand its requirements, we look at the architecture of
the system and the derived requirements for Warlock in this chapter.

Magic Land \citep{magicland} is a social%
\sidenote[2]{
  A social game usually runs on a ``social network'' and allows in-game
  interaction with other users on the same network.
}
resource management game by Wooga%
\sidenote[5]{
  Wooga \citep{wooga} is a games company developing games on social networks 
  and mobile platforms.
}
. The game is used by hundreds to thousands of users everyday resulting in
thousands of HTTP requests every second. 90\% of these requests are writes.
This requires the backend%
\sidenote[7]{
  Backend is the part of the system that handles all the user's actions and
  state and is not directly accessed by the user.
}
handle lot of requests that are not cacheable. Traditional solutions which
involves using stateless servers for application mangement and all state managed
by databases is not feasible for this access pattern. This let to the creation
of the architecture comprising of stateful servers that handled all the user
state changes and used database only for long term storage.

The system consists of the following components as shown in the figure 
\figureref{magic.land.architecture}.

\begin{figure}
  \captionstyle{\raggedright}

  % Generated with LaTeXDraw 2.0.7
  % Tue Aug 14 11:22:29 CEST 2012
  % \usepackage[usenames,dvipsnames]{pstricks}
  % \usepackage{epsfig}
  % \usepackage{pst-grad} % For gradients
  % \usepackage{pst-plot} % For axes
  \scalebox{1} % Change this value to rescale the drawing.
  {
    \begin{pspicture}(0,-4.6748357)(10.874835,4.6)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](5.8,4.6)(0.0,3.2)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](5.8,1.8)(0.0,-1.4)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](6.0,1.6)(0.2,-1.6)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](6.2,1.4)(0.4,-1.8)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](5.4,0.0)(1.4,-1.2)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](5.6,-0.2)(1.6,-1.4)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](5.8,-0.4)(1.8,-1.6)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](10.8,0.6)(7.8,-0.8)
      \psframe[linewidth=0.038,dimen=outer,shadow=true,fillstyle=solid](6.2,-3.2)(0.2,-4.6)
      \usefont{T1}{ptm}{m}{n}
      \rput(2.9145312,3.905){Co-ordinator}
      \usefont{T1}{ptm}{m}{n}
      \rput(3.2114062,0.705){Workers}
      \usefont{T1}{ptm}{m}{n}
      \rput(3.7925,-0.895){Sessions}
      \usefont{T1}{ptm}{m}{n}
      \rput(3.2517188,-3.895){Database}
      \usefont{T1}{ptm}{m}{n}
      \rput(9.2475,-0.095){Lock Manager}
      \psline[linewidth=0.038cm,arrowsize=0.042cm 2.0,arrowlength=0.58,arrowinset=0.4,doubleline=true,doublesep=0.12]{<->}(3.0,3.0)(3.0,2.0)
      \psline[linewidth=0.038cm,arrowsize=0.042cm 2.0,arrowlength=0.58,arrowinset=0.4,doubleline=true,doublesep=0.12]{<->}(3.0,-2.0)(3.0,-3.0)
      \psline[linewidth=0.038cm,arrowsize=0.042cm 2.0,arrowlength=0.58,arrowinset=0.4,doubleline=true,doublesep=0.12]{<->}(7.6,-0.2)(6.6,-0.2)
    \end{pspicture} 
  }

  \caption[Magic Land Architecture]{%
    The figure depicts the high level view of the Magic Land system 
    architecure.}
    \label{figure:magic.land.architecture}
  \normalcaption
\end{figure}

\begin{itemize}
    \iterm{Database}: The database is used to store the user's session for
    a long time when the user is offline.
    \iterm{Co-ordinator}: The co-ordinator decides on which worker a user's 
    session need to be started on.
    \iterm{Worker}: User sessions are run on the worker. Each user session 
    consisits of an stateful Erlang process that handles all the requests
    generated by the user for that specific session.
    \iterm{Lock Manager}: Strictly one session of the user needs to be 
    running atany given point in order to avoid creating conflicting states. 
    This is done by using a lock service that needs to be checked before 
    starting a new user session.
\end{itemize}

A typical user flow consists of the user trying to load the game. The requests
is sent to the co-ordinator which locates a suitable worker and asks it to
start the session for the given user. The worker tries to create a lock on
the users session by making a call to the lock manager with the user's id.
On successful lock, the worker loads the user's state from the database and
notifies that it is ready to accept requests.

The lock manager used is Redis \citep{redis}%
\sidenote[-3]{
  Redis is a performance oriented key-value store with support for multiple
  data structures and atomic primitives.
}
. The worker uses the redis command SETNX%
\sidenote{
  \texttt{SETNX key value} - sets the \texttt{key} to hold \texttt{value} in a 
  hash table only if \texttt{key} does not already exist in the table.
}. This makes sure that the worker can only start a new session if one is 
not already running. Redis also supports asynchronous replication allowing the 
data to be available in multiple locations.

While Redis is an excellent solution to the problem, it also becomes a single
point of failure for the entire system since no new sessions can be created in 
the system if it is down. The goal of this thesis project is to try and replace
Redis as a locking system while being fault tolerant.

From the above background, we can now elaborate the system requirements:

\section{Key value store}

\req{The system should act as a key value store.}

The user is referenced across the system uniquely using a numeric id (UID). The 
user's session present in any of the workers can be uniquely referenced across 
all the workers uniquely using the session's process id (PID). The UID maps to
PID and this mapping is stored in the lock manager. To support this, the lock
manager should support the hash table primitives.

\section{Strong consistency}

\req{All processes accessing the system should see the same results.}

The lock manager will be accessed by multiple workers concurrently. This 
requires the the manager provide a consistent view to all the workers in
order to avoid session duplication.

\section{Maximize availability}

\req{The system should target for maximum possible availability.}

Any downtime of the lock manager will translate to the game being unavailable
for a lot of users. The system should try to maximize availability by various
means.

\section{High read to write ratio}

\req{The manager should be designed and optimized to handle large read to write 
ratio.}

The UID to PID mapping is read by multiple workers many times during the life 
of a user session as compared to writes which happen only when the user tries
to login. This means that the system can be opitimized to maximize reads as
compared to writes.

\section{Dynamic node addition and removal}

\req{It should be possible to add/remove nodes from the system as long as a 
certain minimum number of nodes are available.}

Individual servers within a distributed system are susceptable to failures.
It should be possible to replace the failed servers wihtout being forced
to restart the system.

As the number of users in the game grows, so does the number of requests to
the backend. The system should be able to handle additional load by allowing
addition of nodes dynamically.


\section{Masterless / System with master election}

\req{The system should not have a single point of failure.}

The system should not use special nodes whose failure can lead to the
entire system being out if service.

\section{Fault / failure tolerant}

\req{The system should handle node failures gracefully.}

Server failures in the system should be handled without affecting the service.
Individual failures should not cascade to rest of the system as well.

\section{Lease}

\req{It should be possible to expire keys after a certain amount of time.}

The system should support the pritimive that expires (deletes) the keys after 
the specified time. This feature allows us to clear the system even in case
the worker missed it during session cleanup.

\section{Simple API}

\req{The system should have a simple API.}

The system should have a simple interface and should be simple to communicate 
with.

\section{Language support}

\req{The system should be written in Erlang.}

Almost the entire backed stack of Magic Land is written in Erlang. Having the
lock manager also in Erlang will allow it to communicate with existing
system in a more robust manner.

\section{Performance}

\req{The system needs to have high throughput.}

The system needs to be able to provide high throughtput required to handle
millions of users.

